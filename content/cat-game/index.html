<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Cat Jump — Pixel Cat & Buckets</title>
<style>
  :root{--sky:#cce7ff;--ground:#654321}
  html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
  body{background:var(--sky);display:flex;align-items:center;justify-content:center}
  #gameCanvas{background:transparent;display:block;border:1px solid rgba(0,0,0,0.06)}
  .hud{position:absolute;left:12px;top:12px;background:rgba(255,255,255,0.95);padding:8px 10px;border-radius:8px;box-shadow:0 6px 18px rgba(0,0,0,0.08)}
  .controls{position:absolute;right:12px;top:12px;background:rgba(255,255,255,0.95);padding:8px 10px;border-radius:8px}
  kbd{background:#eee;padding:2px 6px;border-radius:4px;border:1px solid #ddd}
  .badge{position:absolute;left:12px;top:72px;background:rgba(255,255,255,0.95);padding:6px 8px;border-radius:6px;font-size:12px;display:none}
  button{cursor:pointer}
</style>
</head>
<body>
<canvas id="gameCanvas" width="800" height="400" aria-label="Cat Jump game canvas"></canvas>
<div class="hud"><strong>Cat Jump</strong><div style="font-size:13px">Use <kbd>↑</kbd> to jump, <kbd>→</kbd> to move forward — avoid water buckets and falling dogs.</div></div>
<div class="controls"><span id="score">Score: 0</span>&nbsp;&nbsp;<button id="restartBtn">Restart</button></div>
<div class="badge" id="suppressionBadge">Detected external MetaMask messages (filtered for UI cleanliness)</div>

<script>
// --- Game implementation (self-contained, pixel cat & vector buckets) ---
(function(){
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  if (!ctx){ document.body.innerHTML = '<div style="padding:20px">Canvas not supported</div>'; return; }

  const CANVAS_W = canvas.width, CANVAS_H = canvas.height, GROUND_Y = 340;

  // Pixel sprite: 10x10 map ('.' transparent, 'O' orange, 'W' white, 'P' pink)
  const catPixels = [
    '....OO....',
    '...OOOO...',
    '..OOOOOO..',
    '.OOO..OOO.',
    '.OO.W.WOO.',
    '.OO..P.OO.',
    '.OO....OO.',
    '.OO....OO.',
    '..OOOOOO..',
    '...OOOO...'
  ];
  const colorMap = { 'O':'#FF9F1C', 'W':'#FFFFFF', 'P':'#FF6B9A', '.':null };
  const PIXEL_SCALE = 4; // sprite 40x40
  const SPRITE_W = catPixels[0].length * PIXEL_SCALE;
  const SPRITE_H = catPixels.length * PIXEL_SCALE;

  // Game state
  const cat = { x: 50, y: GROUND_Y - SPRITE_H, width: SPRITE_W, height: SPRITE_H, vy: 0, jumping: false };
  let gravity = 0.55, jumpPower = -14;
  let baseSpeed = 3;
  let obstacles = [], dogs = [];
  let frame = 0, score = 0, gameOver = false;

  let level = 1;
  let levelUpTimer = 0;

  function drawPixelSprite(map, x, y, scale){
    for (let r=0;r<map.length;r++){
      const row = map[r];
      for (let c=0;c<row.length;c++){
        const ch = row[c]; const color = colorMap[ch];
        if (!color) continue;
        ctx.fillStyle = color; ctx.fillRect(x + c*scale, y + r*scale, scale, scale);
      }
    }
  }

  function drawCat(){ drawPixelSprite(catPixels, Math.round(cat.x), Math.round(cat.y), PIXEL_SCALE); }

  function drawBucket(x,y,w,h){
    // bucket body
    ctx.fillStyle = '#B0B0B0';
    ctx.beginPath(); ctx.moveTo(x + w*0.15, y + h*0.15); ctx.lineTo(x + w*0.85, y + h*0.15); ctx.lineTo(x + w*0.75, y + h); ctx.lineTo(x + w*0.25, y + h); ctx.closePath(); ctx.fill();
    // rim
    ctx.fillStyle = '#909090'; ctx.fillRect(x + w*0.12, y, w*0.76, h*0.18);
    // water
    ctx.fillStyle = '#4FC3F7'; ctx.fillRect(x + w*0.18, y + h*0.2, w*0.64, h*0.4);
    // shine
    ctx.fillStyle = '#BFEFFF80'; ctx.fillRect(x + w*0.22, y + h*0.22, w*0.18, h*0.12);
  }

  function drawDog(x,y,w,h){
    ctx.fillStyle = '#8B5A2B'; ctx.fillRect(x, y + h*0.25, w, h*0.5); ctx.fillRect(x + w*0.7, y, w*0.3, h*0.3);
    // flame
    ctx.fillStyle = '#FF6B00'; ctx.beginPath(); ctx.ellipse(x + w/2, y + h + 6, w*0.3, 8, 0, 0, Math.PI*2); ctx.fill();
    ctx.fillStyle = '#FFD166'; ctx.beginPath(); ctx.ellipse(x + w/2, y + h + 4, w*0.18, 5, 0, 0, Math.PI*2); ctx.fill();
  }

  function spawnObstacle(){
    const w = 28 + Math.random()*36;
    const h = 28 + Math.random()*28;
    obstacles.push({ x: CANVAS_W + 10, y: GROUND_Y - h, width: w, height: h });
  }
  function spawnDog(){
    const w=32,h=28;
    dogs.push({ x: 20 + Math.random()*(CANVAS_W-60), y: -40, width: w, height: h, vy: 2 + Math.random()*2, alive: true });
  }

  function rectsOverlap(a,b){
    return a.x < b.x + b.width && a.x + a.width > b.x && a.y < b.y + b.height && a.y + a.height > b.y;
  }

  // Input
  const keys = {};
  window.addEventListener('keydown', function(e){
    keys[e.code] = true;
    if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space'].includes(e.code)) e.preventDefault();
  });
  window.addEventListener('keyup', function(e){
    keys[e.code] = false;
  });

  // touch
  let touchRight = false;
  canvas.addEventListener('touchstart', function(e){
    e.preventDefault();
    const t = e.touches[0];
    if (t.clientX > window.innerWidth/2) touchRight = true;
    keys['ArrowUp'] = true;
  });
  canvas.addEventListener('touchend', function(e){
    e.preventDefault();
    touchRight = false;
    keys['ArrowUp'] = false;
  });

  function update(){
    if (gameOver) return;
    frame++;

    if ((keys['ArrowUp'] || keys['KeyW']) && !cat.jumping){
      cat.vy = jumpPower;
      cat.jumping = true;
    }

    const forward = (keys['ArrowRight'] || keys['KeyD'] || touchRight) ? baseSpeed : 0;

    cat.vy += gravity;
    cat.y += cat.vy;
    cat.x += forward;

    if (cat.x < 0) cat.x = 0;
    if (cat.x + cat.width > CANVAS_W) cat.x = CANVAS_W - cat.width;

    if (cat.y + cat.height >= GROUND_Y){
      cat.y = GROUND_Y - cat.height;
      cat.vy = 0;
      cat.jumping = false;
    }

    // Level up if cat reaches right edge (with some margin)
    if (cat.x + cat.width >= CANVAS_W - 2 && !gameOver){
      levelUp();
      return; // skip rest of update this frame to avoid collision immediately after reset
    }

    // Spawn obstacles and dogs faster as level increases
    const obstacleSpawnRate = Math.max(60, 100 - level * 10); // lower means more frequent
    const dogSpawnRate = Math.max(100, 180 - level * 20);

    if (frame % obstacleSpawnRate === 0 && Math.random() < 0.8) spawnObstacle();
    if (frame % dogSpawnRate === 0 && Math.random() < 0.6) spawnDog();

    // Move obstacles faster per level
    const obstacleSpeed = baseSpeed + 0.6 + Math.floor(score/80)*0.08 + (level - 1) * 0.7;
    for (let o of obstacles) o.x -= obstacleSpeed;
    obstacles = obstacles.filter(o => o.x + o.width > -30);

    // Move dogs faster per level
    const dogSpeedInc = (level - 1) * 0.6;
    for (let d of dogs){
      d.y += d.vy + dogSpeedInc;
      if (d.y > CANVAS_H + 60) d.alive = false;
    }
    dogs = dogs.filter(d => d.alive);

    // Collisions
    for (let o of obstacles) if (rectsOverlap(cat, o)) gameOver = true;
    for (let d of dogs) if (rectsOverlap(cat, d)) gameOver = true;

    // Score update
    if (!gameOver && frame % 10 === 0){
      score++;
      document.getElementById('score').textContent = 'Score: ' + score + ' | Level: ' + level;
    }

    if (gameOver) document.getElementById('suppressionBadge').style.display = 'none';

    // Handle level up message timer
    if (levelUpTimer > 0){
      levelUpTimer--;
      if (levelUpTimer === 0){
        // Clear the message by redrawing next frame
        draw();
      }
    }
  }

  function levelUp(){
    level++;
    levelUpTimer = 90; // ~1.5 seconds at 60fps

    // Reset cat position
    cat.x = 50;
    cat.y = GROUND_Y - cat.height;
    cat.vy = 0;
    cat.jumping = false;

    // Clear hazards
    obstacles = [];
    dogs = [];

    // Reset frame count to avoid immediate spawn clutter
    frame = 0;

    // Optional: increase base speed slightly
    baseSpeed += 0.3;
  }

  function drawBackground(){
    // Change background color by level (cycles every 3 levels)
    const lvlMod = (level - 1) % 3;
    if (lvlMod === 0){
      // Day: light blue
      ctx.fillStyle = '#9BD0FF';
      ctx.fillRect(0, 0, CANVAS_W, GROUND_Y);
    } else if (lvlMod === 1){
      // Sunset: orange-pink gradient
      let grad = ctx.createLinearGradient(0,0,CANVAS_W,GROUND_Y);
      grad.addColorStop(0,'#FF9A6A');
      grad.addColorStop(0.5,'#FF5E62');
      grad.addColorStop(1,'#FFD194');
      ctx.fillStyle = grad;
      ctx.fillRect(0,0,CANVAS_W,GROUND_Y);
    } else {
      // Night: dark blue with stars
      ctx.fillStyle = '#0B1E3D';
      ctx.fillRect(0,0,CANVAS_W,GROUND_Y);
      drawStars();
    }

    // Ground stays same color
    ctx.fillStyle = 'var(--ground)';
    ctx.fillRect(0,GROUND_Y,CANVAS_W,CANVAS_H-GROUND_Y);
  }

  function drawStars(){
    // Simple random stars based on level & frame so stars twinkle gently
    const starCount = 50;
    ctx.fillStyle = '#FFF';
    for(let i=0; i<starCount; i++){
      const x = (i * 47 + frame*2) % CANVAS_W;
      const y = ((i * 37 + frame) % (GROUND_Y - 20)) + 10;
      const alpha = 0.5 + 0.5 * Math.sin((frame + i * 10) * 0.05);
      ctx.globalAlpha = alpha;
      ctx.fillRect(x, y, 2, 2);
    }
    ctx.globalAlpha = 1;
  }

  function draw(){
    ctx.clearRect(0,0,CANVAS_W,CANVAS_H);

    drawBackground();

    // draw obstacles/dogs/cat
    for (let o of obstacles) drawBucket(o.x, o.y, o.width, o.height);
    for (let d of dogs) drawDog(d.x, d.y, d.width, d.height);
    drawCat();

    if (levelUpTimer > 0){
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.fillRect(0, CANVAS_H/2 - 40, CANVAS_W, 80);
      ctx.fillStyle = '#FFD700';
      ctx.font = '48px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('Level Up!', CANVAS_W/2, CANVAS_H/2 + 15);
    }

    if (gameOver){
      ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(0,0,CANVAS_W,CANVAS_H);
      ctx.fillStyle = '#fff'; ctx.font = '40px system-ui'; ctx.textAlign = 'center'; ctx.fillText('Game Over', CANVAS_W/2, CANVAS_H/2 - 10);
      ctx.font = '18px system-ui'; ctx.fillText('Press Restart to play again', CANVAS_W/2, CANVAS_H/2 + 22);
    }
  }

  function loop(){
    try{
      update();
      draw();
    }catch(err){
      console.error('Game loop error', err);
      gameOver = true;
    }
    requestAnimationFrame(loop);
  }

  document.getElementById('restartBtn').addEventListener('click', function(){
    obstacles = []; dogs = []; frame = 0; score = 0; gameOver = false; level = 1; baseSpeed = 3; levelUpTimer = 0;
    cat.x = 50; cat.y = GROUND_Y - cat.height; cat.vy = 0; cat.jumping = false;
    document.getElementById('score').textContent = 'Score: 0 | Level: 1';
  });

  // Test helpers
  window.__test_addHazards = function(){ obstacles.push({x:500,y:GROUND_Y-40,width:40,height:40}); dogs.push({x:320,y:40,width:32,height:28,vy:2,alive:true}); };
  window.__test_spawnObstacle = function(){ spawnObstacle(); };
  window.__test_simulateMetaMaskError = function(){
    try{ window.dispatchEvent(new ErrorEvent('error',{message:'Failed to connect to MetaMask (simulated)'})); }catch(e){ console.warn('simulate failed',e); }
  };

  // Initialize display with level too
  document.getElementById('score').textContent = 'Score: 0 | Level: 1';

  loop();
})();
</script>

</body>
</html>
