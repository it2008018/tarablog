<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Cat Jump — Pixel Cat & Buckets</title>
<style>
  :root{--sky:#cce7ff;--ground:#654321}
  html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
  body{background:var(--sky);display:flex;align-items:center;justify-content:center}
  #gameCanvas{background:transparent;display:block;border:1px solid rgba(0,0,0,0.06)}
  .hud{position:absolute;left:12px;top:12px;background:rgba(255,255,255,0.95);padding:8px 10px;border-radius:8px;box-shadow:0 6px 18px rgba(0,0,0,0.08)}
  .controls{position:absolute;right:12px;top:12px;background:rgba(255,255,255,0.95);padding:8px 10px;border-radius:8px}
  kbd{background:#eee;padding:2px 6px;border-radius:4px;border:1px solid #ddd}
  .badge{position:absolute;left:12px;top:72px;background:rgba(255,255,255,0.95);padding:6px 8px;border-radius:6px;font-size:12px;display:none}
  button{cursor:pointer}
</style>
</head>
<body>
<canvas id="gameCanvas" width="800" height="400" aria-label="Cat Jump game canvas"></canvas>
<div class="hud"><strong>Cat Jump</strong><div style="font-size:13px">Use <kbd>↑</kbd> to jump, <kbd>→</kbd> to move forward — avoid water buckets and falling fire. Reach right wall to cross the level !</div></div>
<div class="controls"><span id="score">Score: 0</span>&nbsp;&nbsp;<button id="restartBtn">Restart</button></div>
<div class="badge" id="suppressionBadge">Detected external MetaMask messages (filtered for UI cleanliness)</div>

<script>
// --- Game implementation (self-contained, pixel cat & vector buckets) ---
(function(){
  const canvas = document.getElementById('gameCanvas');
  const ctx = canvas.getContext('2d');
  if (!ctx){ document.body.innerHTML = '<div style="padding:20px">Canvas not supported</div>'; return; }

  const CANVAS_W = canvas.width, CANVAS_H = canvas.height, GROUND_Y = 340;
  const GROUND_COLOR = getComputedStyle(document.documentElement).getPropertyValue('--ground').trim() || '#654321';

  // Pixel sprite: 10x10 map ('.' transparent)
  // Updated to a more cat-like sprite with ears, eyes and a nose
  const catPixels = [
    '..B....B..',
    '.BBBBBBBB.',
    'BBGGGGGGBB',
    'BGWGGGGWGB',
    'BGGGPGGGGB',
    'BGGGGGGGGB',
    'BBGGGGGGBB',
    'BGGGGGGGGB',
    'BGGGGGGGGB',
    '.BBBBBBBB.'
  ];
  const colorMap = { 'B':'#333333', 'G':'#9E9E9E', 'W':'#FFFFFF', 'P':'#FF6B9A', 'O':'#FF9F1C', '.':null };
  const PIXEL_SCALE = 4; // sprite 40x40
  const SPRITE_W = catPixels[0].length * PIXEL_SCALE;
  const SPRITE_H = catPixels.length * PIXEL_SCALE;

  // Game state
  const cat = { x: 50, y: GROUND_Y - SPRITE_H, width: SPRITE_W, height: SPRITE_H, vy: 0, jumping: false };
  let gravity = 0.55, jumpPower = -14;
  let baseSpeed = 3;
  let obstacles = [], dogs = [];
  let frame = 0, score = 0, gameOver = false;

  let level = 1;
  let levelUpTimer = 0;
  // Ground decoration: stones cache
  let groundStones = [];
  let stonesLevel = 0;
  // Global scale factor for trees
  const TREE_SCALE = 1.5;
  // Global scale factor for dogs (fire) — 1x bigger = 2.0x size
  const DOG_SCALE = 2.0;

  function drawPixelSprite(map, x, y, scale){
    for (let r=0;r<map.length;r++){
      const row = map[r];
      for (let c=0;c<row.length;c++){
        const ch = row[c]; const color = colorMap[ch];
        if (!color) continue;
        ctx.fillStyle = color; ctx.fillRect(x + c*scale, y + r*scale, scale, scale);
      }
    }
  }

  function drawCat(){ drawPixelSprite(catPixels, Math.round(cat.x), Math.round(cat.y), PIXEL_SCALE); }

  function drawBucket(x,y,w,h){
    // More defined, glass-like water container with rim, handle, gradients and shadows
    // Now with subtle tilt/sway for extra polish (rotates around bottom center)
    ctx.save();

    const pivotX = x + w*0.5;
    const pivotY = y + h;
    const sway = 0.08 * Math.sin((frame + x) * 0.04); // gentle oscillation
    const lean = -0.02; // slight lean into motion
    const angle = sway + lean;
    ctx.translate(pivotX, pivotY);
    ctx.rotate(angle);
    ctx.translate(-pivotX, -pivotY);

    const topY = y + h*0.15;
    const leftTop = x + w*0.15, rightTop = x + w*0.85;
    const leftBottom = x + w*0.25, rightBottom = x + w*0.75;

    // Body path
    ctx.beginPath();
    ctx.moveTo(leftTop, topY);
    ctx.lineTo(rightTop, topY);
    ctx.lineTo(rightBottom, y + h);
    ctx.lineTo(leftBottom, y + h);
    ctx.closePath();

    // Metal/glass gradient for body
    let bodyGrad = ctx.createLinearGradient(0, topY, 0, y + h);
    bodyGrad.addColorStop(0, '#D7D7D7');
    bodyGrad.addColorStop(0.5, '#AEAEAE');
    bodyGrad.addColorStop(1, '#CFCFCF');
    ctx.fillStyle = bodyGrad;
    ctx.fill();

    // Outline
    ctx.lineWidth = Math.max(1.5, w * 0.02);
    ctx.strokeStyle = '#6F6F6F';
    ctx.stroke();

    // Top rim (ellipse)
    const rimCx = x + w * 0.5;
    const rimCy = y + h * 0.13;
    const rimRx = w * 0.38;
    const rimRy = h * 0.06;
    ctx.beginPath();
    ctx.ellipse(rimCx, rimCy, rimRx, rimRy, 0, 0, Math.PI*2);
    let rimGrad = ctx.createLinearGradient(rimCx, rimCy - rimRy, rimCx, rimCy + rimRy);
    rimGrad.addColorStop(0, '#CFCFCF');
    rimGrad.addColorStop(1, '#9C9C9C');
    ctx.fillStyle = rimGrad;
    ctx.fill();
    ctx.lineWidth = Math.max(1, w * 0.015);
    ctx.strokeStyle = '#7A7A7A';
    ctx.stroke();

    // Inner cavity clip for water and inner shading
    const inset = w * 0.03;
    const iTopY = y + h * 0.20;
    const iBottomY = y + h * 0.88;
    const iLeftTop = leftTop + inset, iRightTop = rightTop - inset;
    const iLeftBottom = leftBottom + inset, iRightBottom = rightBottom - inset;
    ctx.save();
    ctx.beginPath();
    ctx.moveTo(iLeftTop, iTopY);
    ctx.lineTo(iRightTop, iTopY);
    ctx.lineTo(iRightBottom, iBottomY);
    ctx.lineTo(iLeftBottom, iBottomY);
    ctx.closePath();
    ctx.clip();

    // Water volume (with trapezoid to match glass walls)
    const waterTopY = y + h * 0.22;
    const waterBottomY = y + h * 0.65;
    ctx.beginPath();
    ctx.moveTo(iLeftTop, waterTopY);
    ctx.lineTo(iRightTop, waterTopY);
    ctx.lineTo(iRightBottom, waterBottomY);
    ctx.lineTo(iLeftBottom, waterBottomY);
    ctx.closePath();
    let waterGrad = ctx.createLinearGradient(0, waterTopY, 0, waterBottomY);
    waterGrad.addColorStop(0, '#7AD6FF');
    waterGrad.addColorStop(0.6, '#34A9E6');
    waterGrad.addColorStop(1, '#1488CC');
    ctx.fillStyle = waterGrad;
    ctx.fill();

    // Water surface meniscus highlight (ellipse)
    ctx.globalAlpha = 0.45;
    ctx.beginPath();
    ctx.ellipse(rimCx, waterTopY + h*0.01, rimRx * 0.82, rimRy * 0.55, 0, 0, Math.PI*2);
    let meniscus = ctx.createRadialGradient(rimCx, waterTopY, 0, rimCx, waterTopY, rimRx * 0.9);
    meniscus.addColorStop(0, 'rgba(255,255,255,0.9)');
    meniscus.addColorStop(1, 'rgba(255,255,255,0)');
    ctx.fillStyle = meniscus;
    ctx.fill();
    ctx.globalAlpha = 1;

    // Inner gloss stripes
    ctx.fillStyle = 'rgba(255,255,255,0.25)';
    ctx.fillRect(x + w*0.32, y + h*0.22, w*0.04, h*0.58);
    ctx.fillStyle = 'rgba(255,255,255,0.12)';
    ctx.fillRect(x + w*0.37, y + h*0.27, w*0.02, h*0.50);

    // Inner vertical shadow for depth
    let innerShadow = ctx.createLinearGradient(0, iTopY, 0, iBottomY);
    innerShadow.addColorStop(0, 'rgba(0,0,0,0.10)');
    innerShadow.addColorStop(0.5, 'rgba(0,0,0,0)');
    innerShadow.addColorStop(1, 'rgba(0,0,0,0.12)');
    ctx.fillStyle = innerShadow;
    ctx.fillRect(iLeftTop, iTopY, iRightTop - iLeftTop, iBottomY - iTopY);

    ctx.restore(); // end inner clip

    // Side seams for definition
    ctx.strokeStyle = 'rgba(0,0,0,0.15)';
    ctx.lineWidth = Math.max(1, w * 0.01);
    ctx.beginPath(); ctx.moveTo(leftTop, topY); ctx.lineTo(leftBottom, y + h); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(rightTop, topY); ctx.lineTo(rightBottom, y + h); ctx.stroke();

    // Handle
    ctx.strokeStyle = '#7A7A7A';
    ctx.lineWidth = Math.max(1.5, w * 0.025);
    ctx.beginPath();
    ctx.arc(rimCx, y + h * 0.02, w * 0.35, Math.PI * 0.95, Math.PI * 0.05, false);
    ctx.stroke();
    // handle joints
    ctx.fillStyle = '#8A8A8A';
    ctx.beginPath(); ctx.arc(leftTop, topY, Math.max(1.5, w*0.02), 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(rightTop, topY, Math.max(1.5, w*0.02), 0, Math.PI*2); ctx.fill();

    ctx.restore(); // end rotation

    // Ground shadow (not rotated)
    ctx.save();
    ctx.globalAlpha = 0.22;
    ctx.fillStyle = '#000';
    ctx.beginPath();
    ctx.ellipse(x + w*0.5, y + h + Math.max(3, h*0.04), w*0.38, Math.max(4, h*0.12), 0, 0, Math.PI*2);
    ctx.fill();
    ctx.globalAlpha = 1;
    ctx.restore();
  }

function drawDog(x, y, w, h){
  // Rounder, larger flame (fire)
  const flicker = 1 + Math.sin(frame * 0.18 + x * 0.01) * 1.2;
  const cx = x + w / 2;
  const top = y;
  const bottom = y + h;

  // Outer glow
  ctx.save();
  ctx.shadowColor = 'rgba(255,140,0,0.6)';
  ctx.shadowBlur = Math.max(6, w * 0.15);

  // Rounded flame body
  ctx.beginPath();
  ctx.moveTo(cx, top);
  ctx.bezierCurveTo(x + w * 0.9, y + h * 0.28, x + w * 0.9, y + h * 0.72, cx, bottom);
  ctx.bezierCurveTo(x + w * 0.1, y + h * 0.72, x + w * 0.1, y + h * 0.28, cx, top);
  ctx.closePath();

  let grad = ctx.createRadialGradient(cx, y + h * 0.58, w * 0.12, cx, y + h * 0.58, w * 0.65);
  grad.addColorStop(0, '#FFF176');
  grad.addColorStop(0.45, '#FF9800');
  grad.addColorStop(1, '#D84315');
  ctx.fillStyle = grad;
  ctx.fill();
  ctx.restore();

  // Inner bright cores
  ctx.save();
  ctx.globalAlpha = 0.9;
  ctx.fillStyle = 'rgba(255,255,255,0.85)';
  ctx.beginPath();
  ctx.ellipse(cx, y + h * 0.58 + flicker * 0.6, w * 0.16, h * 0.24, 0, 0, Math.PI * 2);
  ctx.fill();

  ctx.globalAlpha = 0.6;
  ctx.fillStyle = 'rgba(255,255,255,0.6)';
  ctx.beginPath();
  ctx.ellipse(cx + w * 0.08 * Math.sin(frame * 0.1), y + h * 0.38, w * 0.11, h * 0.18, 0, 0, Math.PI * 2);
  ctx.fill();
  ctx.restore();
}


  function spawnObstacle(){
    // Slightly wider buckets
    const w = 36 + Math.random()*40; // was 28 + Math.random()*36
    const h = 28 + Math.random()*28;
    obstacles.push({ x: CANVAS_W + 10, y: GROUND_Y - h, width: w, height: h });
  }
  function spawnDog(){
    const w = 32 * DOG_SCALE, h = 28 * DOG_SCALE;
    dogs.push({ x: 20 + Math.random()*(CANVAS_W-60), y: -40, width: w, height: h, vy: 2 + Math.random()*2, alive: true });
  }

  function rectsOverlap(a,b){
    return a.x < b.x + b.width && a.x + a.width > b.x && a.y < b.y + b.height && a.y + a.height > b.y;
  }

  // Input
  const keys = {};
  window.addEventListener('keydown', function(e){
    keys[e.code] = true;
    if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight','Space'].includes(e.code)) e.preventDefault();
  });
  window.addEventListener('keyup', function(e){
    keys[e.code] = false;
  });

  // touch
  let touchRight = false;
  canvas.addEventListener('touchstart', function(e){
    e.preventDefault();
    const t = e.touches[0];
    if (t.clientX > window.innerWidth/2) touchRight = true;
    keys['ArrowUp'] = true;
  });
  canvas.addEventListener('touchend', function(e){
    e.preventDefault();
    touchRight = false;
    keys['ArrowUp'] = false;
  });
  
let currentLevel = 1;
let lives = 3;

function startLevel(level) {
    console.log(`Starting Level ${level}`);
    // reset positions, obstacles, and other variables for this level
}

function loseLife() {
    lives--;
    if (lives <= 0) {
        gameOver = true;
        restartFromSameLevel();
    }
}

function restartFromSameLevel() {
    lives = 3; // or whatever you want to reset
    gameOver = false;
    startLevel(currentLevel); // start from same level
}

  function update(){
    if (gameOver) return;
    frame++;

    if ((keys['ArrowUp'] || keys['KeyW']) && !cat.jumping){
      cat.vy = jumpPower;
      cat.jumping = true;
    }

    const forward = (keys['ArrowRight'] || keys['KeyD'] || touchRight) ? baseSpeed : 0;

    cat.vy += gravity;
    cat.y += cat.vy;
    cat.x += forward;

    if (cat.x < 0) cat.x = 0;
    if (cat.x + cat.width > CANVAS_W) cat.x = CANVAS_W - cat.width;

    if (cat.y + cat.height >= GROUND_Y){
      cat.y = GROUND_Y - cat.height;
      cat.vy = 0;
      cat.jumping = false;
    }

    // Level up if cat reaches right edge (with some margin)
    if (cat.x + cat.width >= CANVAS_W - 2 && !gameOver){
      levelUp();
      return; // skip rest of update this frame to avoid collision immediately after reset
    }

    // Spawn obstacles and dogs faster as level increases
    const obstacleSpawnRate = Math.max(60, 100 - level * 10); // lower means more frequent
    const dogSpawnRate = Math.max(100, 180 - level * 20);

    if (frame % obstacleSpawnRate === 0 && Math.random() < 0.8) spawnObstacle();
    if (frame % dogSpawnRate === 0 && Math.random() < 0.6) spawnDog();

    // Move obstacles faster per level
    const obstacleSpeed = baseSpeed + 0.6 + Math.floor(score/80)*0.08 + (level - 1) * 0.7;
    for (let o of obstacles) o.x -= obstacleSpeed;
    obstacles = obstacles.filter(o => o.x + o.width > -30);

    // Move dogs faster per level
    const dogSpeedInc = (level - 1) * 0.6;
    for (let d of dogs){
      d.y += d.vy + dogSpeedInc;
      if (d.y > CANVAS_H + 60) d.alive = false;
    }
    dogs = dogs.filter(d => d.alive);

    // Collisions
    for (let o of obstacles) if (rectsOverlap(cat, o)) gameOver = true;
    for (let d of dogs) if (rectsOverlap(cat, d)) gameOver = true;

    // Score update
    if (!gameOver && frame % 10 === 0){
      score++;
      document.getElementById('score').textContent = 'Score: ' + score + ' | Level: ' + level;
    }

    if (gameOver) document.getElementById('suppressionBadge').style.display = 'none';

    // Handle level up message timer
    if (levelUpTimer > 0){
      levelUpTimer--;
      if (levelUpTimer === 0){
        // Clear the message by redrawing next frame
        draw();
      }
    }
  }

  function levelUp(){
    level++;
    levelUpTimer = 90; // ~1.5 seconds at 60fps

    // Reset cat position
    cat.x = 50;
    cat.y = GROUND_Y - cat.height;
    cat.vy = 0;
    cat.jumping = false;

    // Clear hazards
    obstacles = [];
    dogs = [];

    // Reset frame count to avoid immediate spawn clutter
    frame = 0;

    // Optional: increase base speed slightly
    baseSpeed += 0.3;
  }

  function drawBackground(){
    // Change background color by level (cycles every 3 levels)
    const lvlMod = (level - 1) % 3;
    if (lvlMod === 0){
      // Day: light blue
      ctx.fillStyle = '#9BD0FF';
      ctx.fillRect(0, 0, CANVAS_W, GROUND_Y);
    } else if (lvlMod === 1){
      // Sunset: orange-pink gradient
      let grad = ctx.createLinearGradient(0,0,CANVAS_W,GROUND_Y);
      grad.addColorStop(0,'#FF9A6A');
      grad.addColorStop(0.5,'#FF5E62');
      grad.addColorStop(1,'#FFD194');
      ctx.fillStyle = grad;
      ctx.fillRect(0,0,CANVAS_W,GROUND_Y);
    } else {
      // Night: dark blue with stars
      ctx.fillStyle = '#0B1E3D';
      ctx.fillRect(0,0,CANVAS_W,GROUND_Y);
      drawStars();
    }

    // New: parallax trees between sky and ground
    drawTrees(lvlMod);

    // Ground stays same color
    ctx.fillStyle = GROUND_COLOR;
    ctx.fillRect(0,GROUND_Y,CANVAS_W,CANVAS_H-GROUND_Y);

    // New: stones on ground surface
    ensureGroundStones();
    drawGroundStones();
  }

  function drawStars(){
    // Simple random stars based on level & frame so stars twinkle gently
    const starCount = 50;
    ctx.fillStyle = '#FFF';
    for(let i=0; i<starCount; i++){
      const x = (i * 47 + frame*2) % CANVAS_W;
      const y = ((i * 37 + frame) % (GROUND_Y - 20)) + 10;
      const alpha = 0.5 + 0.5 * Math.sin((frame + i * 10) * 0.05);
      ctx.globalAlpha = alpha;
      ctx.fillRect(x, y, 2, 2);
    }
    ctx.globalAlpha = 1;
  }

  // New helpers: parallax trees
  function drawTrees(lvlMod){
    // lvlMod: 0 day, 1 sunset, 2 night
    const isNight = (lvlMod === 2);

    // Far layer (darker, smaller, slower)
    const spacingF = 180;
    const speedF = 0.35 + (level - 1) * 0.05; // subtle speed increase per level
    const offsetF = (frame * speedF) % spacingF;
    for (let i = -1; i <= Math.ceil(CANVAS_W / spacingF) + 1; i++){
      const x = i * spacingF - offsetF;
      const scale = 0.7 + 0.25 * (0.5 + 0.5 * Math.sin((i + level) * 1.7));
      drawTree(x, GROUND_Y, 0.75 * scale * TREE_SCALE, isNight, true);
    }

    // Near layer (brighter, larger, faster)
    const spacingN = 260;
    const speedN = 0.75 + (level - 1) * 0.08;
    const offsetN = (frame * speedN) % spacingN;
    for (let i = -1; i <= Math.ceil(CANVAS_W / spacingN) + 1; i++){
      const x = i * spacingN - offsetN + 60;
      const scale = 0.95 + 0.4 * (0.5 + 0.5 * Math.sin((i * 1.3 + level) * 1.1));
      drawTree(x, GROUND_Y, 1.0 * scale * TREE_SCALE, isNight, false);
    }
  }

  function drawTree(x, groundY, scale, isNight, isFar){
    const trunkH = (24 * scale) * (isFar ? 0.85 : 1);
    const trunkW = (8 * scale) * (isFar ? 0.85 : 1);
    const canopyR = (16 * scale) * (isFar ? 0.9 : 1.05);

    // Clamp to reasonable sizes (expanded for bigger trees)
    const tH = Math.max(10, Math.min(66, trunkH));
    const tW = Math.max(4, Math.min(21, trunkW));
    const r  = Math.max(10, Math.min(42, canopyR));

    const trunkX = x - tW/2;
    const trunkTopY = groundY - tH;

    ctx.save();

    // Slight sway effect for near layer
    const sway = isFar ? 0 : Math.sin((frame + x) * 0.01) * 0.6;
    ctx.translate(x, trunkTopY + tH);
    ctx.rotate(sway * 0.005);
    ctx.translate(-x, -(trunkTopY + tH));

    // Colors by time of day
    if (isNight){
      ctx.globalAlpha = isFar ? 0.55 : 0.75;
      ctx.fillStyle = '#08223a'; // silhouette
      // trunk
      ctx.fillRect(trunkX, trunkTopY, tW, tH);
      // canopy as blobby shape of circles
      const cy = trunkTopY;
      ctx.beginPath();
      ctx.arc(x, cy - r * 0.2, r, 0, Math.PI * 2);
      ctx.arc(x - r * 0.85, cy + r * 0.05, r * 0.8, 0, Math.PI * 2);
      ctx.arc(x + r * 0.85, cy + r * 0.05, r * 0.78, 0, Math.PI * 2);
      ctx.closePath();
      ctx.fill();
      ctx.globalAlpha = 1;
    } else {
      // Day/Sunset colors
      // trunk
      ctx.fillStyle = isFar ? '#6b4f3a' : '#7a523b';
      ctx.globalAlpha = isFar ? 0.85 : 1;
      ctx.fillRect(trunkX, trunkTopY, tW, tH);

      // canopy gradient
      const topY = trunkTopY - r * 0.8;
      const grad = ctx.createLinearGradient(x, topY, x, trunkTopY + r * 0.6);
      if (isFar){
        grad.addColorStop(0, '#2d5f3a');
        grad.addColorStop(1, '#3a7a4a');
      } else if (!isFar && !isNight){
        // Slightly warmer greens during sunset
        grad.addColorStop(0, '#2e7d32');
        grad.addColorStop(1, '#41a05a');
      }
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.arc(x, trunkTopY, r, 0, Math.PI * 2);
      ctx.arc(x - r * 0.85, trunkTopY + r * 0.15, r * 0.78, 0, Math.PI * 2);
      ctx.arc(x + r * 0.85, trunkTopY + r * 0.15, r * 0.75, 0, Math.PI * 2);
      ctx.closePath();
      ctx.fill();
      ctx.globalAlpha = 1;

      // soft shadow under canopy on trunk for depth
      ctx.fillStyle = 'rgba(0,0,0,0.08)';
      ctx.fillRect(trunkX, trunkTopY + 2, tW, Math.min(tH, r * 0.6));
    }

    ctx.restore();
  }

  // New helpers: ground stones
  function ensureGroundStones(){
    if (stonesLevel !== level || groundStones.length === 0){
      stonesLevel = level;
      groundStones = [];
      const count = 36; // adjust density
      for (let i=0;i<count;i++){
        const rx = 3 + Math.random()*7; // radius x
        const ry = Math.max(2, rx*0.55 + Math.random()*2);
        const x = Math.random()*CANVAS_W;
        const y = GROUND_Y + 6 + Math.random()*26; // sit within top band of ground
        const rot = (Math.random()-0.5) * 0.7;
        const tone = Math.random();
        const color = tone < 0.33 ? '#b1b1ad' : (tone < 0.66 ? '#9a9a95' : '#c2c2bd');
        groundStones.push({ x, y, rx, ry, rot, color });
      }
    }
  }

  function drawGroundStones(){
    ctx.save();
    for (const s of groundStones){
      // shadow
      ctx.save();
      ctx.globalAlpha = 0.22;
      ctx.fillStyle = '#000';
      ctx.beginPath();
      ctx.ellipse(s.x, s.y + s.ry + 2, Math.max(1, s.rx*0.9), Math.max(1, s.ry*0.5), 0, 0, Math.PI*2);
      ctx.fill();
      ctx.restore();

      // stone body with subtle gradient highlight
      ctx.save();
      ctx.translate(s.x, s.y);
      ctx.rotate(s.rot);
      const grad = ctx.createLinearGradient(-s.rx, -s.ry, s.rx, s.ry);
      grad.addColorStop(0, 'rgba(255,255,255,0.28)');
      grad.addColorStop(0.35, s.color);
      grad.addColorStop(1, 'rgba(0,0,0,0.18)');
      ctx.fillStyle = grad;
      ctx.beginPath();
      ctx.ellipse(0, 0, s.rx, s.ry, 0, 0, Math.PI*2);
      ctx.fill();
      // outline
      ctx.strokeStyle = 'rgba(0,0,0,0.12)';
      ctx.lineWidth = 0.8;
      ctx.stroke();
      ctx.restore();
    }
    ctx.restore();
  }

  function draw(){
    ctx.clearRect(0,0,CANVAS_W,CANVAS_H);

    drawBackground();

    // draw obstacles/dogs/cat
    for (let o of obstacles) drawBucket(o.x, o.y, o.width, o.height);
    for (let d of dogs) drawDog(d.x, d.y, d.width, d.height);
    drawCat();

    if (levelUpTimer > 0){
      ctx.fillStyle = 'rgba(0,0,0,0.7)';
      ctx.fillRect(0, CANVAS_H/2 - 40, CANVAS_W, 80);
      ctx.fillStyle = '#FFD700';
      ctx.font = '48px system-ui';
      ctx.textAlign = 'center';
      ctx.fillText('Level Up!', CANVAS_W/2, CANVAS_H/2 + 15);
    }

    if (gameOver){
      ctx.fillStyle = 'rgba(0,0,0,0.6)'; ctx.fillRect(0,0,CANVAS_W,CANVAS_H);
      ctx.fillStyle = '#fff'; ctx.font = '40px system-ui'; ctx.textAlign = 'center'; ctx.fillText('Game Over', CANVAS_W/2, CANVAS_H/2 - 10);
      ctx.font = '18px system-ui'; ctx.fillText('Press Restart to play again', CANVAS_W/2, CANVAS_H/2 + 22);
    }
  }

  function loop(){
    try{
      update();
      draw();
    }catch(err){
      console.error('Game loop error', err);
      gameOver = true;
    }
    requestAnimationFrame(loop);
  }

  document.getElementById('restartBtn').addEventListener('click', function(){
    // Restart from the same level it ended on
    obstacles = []; dogs = []; frame = 0; score = 0; gameOver = false; levelUpTimer = 0;
    // keep current level; recompute base speed for this level
    baseSpeed = 3 + 0.3 * (level - 1);
    cat.x = 50; cat.y = GROUND_Y - cat.height; cat.vy = 0; cat.jumping = false;
    document.getElementById('score').textContent = 'Score: 0 | Level: ' + level;
  });

  // Test helpers
  window.__test_addHazards = function(){
    obstacles.push({ x: 500, y: GROUND_Y - 40, width: 40, height: 40 });
    dogs.push({ x: 320, y: 40, width: 32, height: 28, vy: 2, alive: true });
  };
  window.__test_spawnObstacle = function(){ spawnObstacle(); };
  window.__test_simulateMetaMaskError = function(){
    try{ window.dispatchEvent(new ErrorEvent('error', { message: 'Failed to connect to MetaMask (simulated)' })); }catch(e){ console.warn('simulate failed', e); }
  };

  // Initialize display with level too
  document.getElementById('score').textContent = 'Score: 0 | Level: 1';

  loop();
})();
</script>

</body>
</html>
